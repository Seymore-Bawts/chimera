Here's a pytest unit test that you can use to verify your new scheduling algorithm in `src/core/scheduler` module based on priority and memory cost (randomness added as secondary criteria): 

```python
import operator    # Import required modules  
from collections import defaultdict       # For dependency Graph and adjacency list construction     
def test_schedule():    
        tasks = {'task1': ('depends', 'on'),'task2':('cpu cost','memory') , 
                 'task3': (None, None)}    # Assuming cpu costs are not provided for task dependencies and no common base scenario exists.  
                                                                                   
                                                        if operator.'not in'(tasks['depends'] or tasks[v]):      sortedTasks = [kfor k , v ∈ list(tasks)if (op'depen d onts exist not ops op itemgetter('cpu cost', 'memory') -> ['task1','dependency exists'])   
                                                                                      else:[],['depends'] and tasks[v]]        sortedTasks = [k for k , v ∈ list(tasks)if (ops.itemgetserr on if not ops op itemgetter('cpu cost', 'memory') -> ['task1','dependency exists'])  
                                                                                      else[]]    # This line should be unreachable, but just in case we're getting a TypeError – it makes sense to add an empty list as the default value of sortedTasks.     [k for k , v if not ops op itemgetter('cpu cost', 'memory') -> ['task1','dependency exists'] else []]  
         # This line should be unreachable, but just in case we're getting a TypeError – it makes sense to add an empty list as the default value of sortedTasks.     [k for k , v if not ops op itemgetter('cpu cost', 'memory') -> ['task1','dependency exists'] else []]  
         # Assuming cpu costs are provided and common base scenario exist, sort tasks based on memory usage in descending order with randomness added as a secondary criterion.  sortedTasks = [k for k , v if (ops op itemgetter('cpu cost', 'memory')) -> ['task1','dependency exists'] else []]  
         # This line should be unreachable, but just to make sure this sorting function actually works based on expected inputs and outputs.  sortedTasks = [k for k , v if (ops op itemgetter('cpu cost', 'memory')) -> ['task1','dependency exists'] else []]   
         # Assuming dependencies exist among the tasks, we should be able to run a topological sort algorithm with these values using Khan's Algorithm.  Topology Sort is used here: https://enwiki/TopologicalSorting   and refer below http://www-inst... for more information on how this works in detail
          from src import khansalgorithm as op    # Import the KahnsAlgorithm module that contains our implementation of Khan's algorithm. Refer above link to understand its working under different conditions – it should handle these cases appropriately   run_topologicalsort(edges, 'task1')       
         assert sortedTasks == ['task2', 'task3']    # Verify the expected result is returned by our function     pytest.raises() with some edge case inputs (like when tasks['dependency exists']) and ensure that we get a meaningful assertion error message   run_topologicalsort(edges, None)
```  Note: This test assumes all task dependencies are provided in `tasks` dictionary keys as strings indicating the dependent or dependency on each other's name. The functions under testing (Khan’s algorithm based topological sort implementation from src module), 'run_topologicalsort', will fail if it encounters tasks that do not have a direct dependence, such edge case should be handled by raising an exception to stop pytest failing in those cases and ensure the error message is meaningful. 
You can run this test with `pytest -v` command from your terminal or any IDE you are using for testing purposes (like PyCharm). This will execute only if tests passed, otherwise it would give a failed result along with an assertion/error in console which could help identify where the problem lies. 
Please note that this test needs to be run as part of pytest suite and is designed so you can add more unit testing cases according to your application's requirements by adding `assert` statements inside these tests (alongside any existing ones). It’ll allow easy debugging if assertions fail during runtime. 
Also, please adjust the import paths for 'src', as pytest cannot execute files outside of its current working directory in a standard Python script without additional configuration or setup steps due to various reasons such `sys` and environment variables differences among different operating systems etc. which are not covered here (though can be handled). 
The test cases provided above will only cover the given scenario but depending upon requirements you may need more tests for your use case, adding them as required is a good approach in this regard: add assertions with specific inputs and expected outputs to handle edge or corner-case scenarios. The same applies here too if we are planning on using these functions under different applications/use cases then they should be tailored appropriately by modifying the test data accordingly (as you have correctly noted, it might require more adjustments for this case).
